<main>
    <div class="row justify-content-center">
        <div class="col-12 col-md-8 col-lg-6 text-center">
            <div id="myBoard" style="width: 100%; max-width: calc(100vh - 300px)"></div>
        </div>
        <div class="col-12 col-md-2 order-md-first">
            <div class="row">
                <div class="col-4 col-md-12">
                    <div id="connections">
                        <div style="font-weight: bold">White:</div>
                        <div id="whiteName"></div>
                        <div id="whiteStatus" style="font-style: italic">disconnected</div>
                        <div style="font-weight: bold">Black:</div>
                        <div id="blackName"></div>
                        <div id="blackStatus" style="font-style: italic">disconnected</div>
                        <div style="font-weight: bold">Observers:</div>
                        <div id="noObservers" style="font-style: italic">none</div>
                        <div id="observers"></div>
                    </div>
                    <br/>
                </div>
                <div class="col-4 col-md-12">
                    <div class="playerInfo">
                        <label style="font-weight: bold">Your color:</label>
                        <div>{{player}}</div>
                        <br/>
                    </div>
                    <div id="flipButton">
                        <button id="flip" type="button">Flip Board Perspective</button>
                        <br/>
                        <br/>
                    </div>
                    <label style="font-weight: bold">Status:</label>
                    <div id="status"></div>
                    <br/>
                </div>
                <div class="col-4 col-md-12">
                    <div id="promotionsChoice" class="playerInput">
                        <label style="font-weight: bold">Pawn promotions:</label>
                        <div id="promotions">
                            <input type="radio" id="queen" name="promotion" value="q" checked="default">
                            <label for="queen">Queen</label><br/>
                            <input type="radio" id="rook" name="promotion" value="r">
                            <label for="rook">Rook</label><br/>
                            <input type="radio" id="knight" name="promotion" value="n">
                            <label for="knight">Knight</label><br/>
                            <input type="radio" id="bishop" name="promotion" value="b">
                            <label for="bishop">Bishop</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-12 col-md-2">
            <label style="font-weight: bold">PGN:</label>
            <div id="pgn"></div>
        </div>
        <div class="col-12">
            <br />
            <div class="row justify-content-center">
                <div id="chatBox" class="col-12 col-md-10 col-lg-8" style="overflow-y: scroll; overflow-x:wrap; height: 150px; border: 1px solid black">
                    <div id="chatDiv"></div>
                </div>
                <div id="chatTypeBox" class="col-12 col-md-10 col-lg-8 playerInput">
                    <input id="inputMessage" style="width:calc(100% - 54px)" placeholder="Type here..."/><button onClick=sendMessage()>Send</button>
                </div>
            </div>
        </div>
    </div>
    <script type="text/javascript">
        let decodedJson = decodeURIComponent("{{{encodedJson}}}"), userData = JSON.parse(decodedJson), socket = io('/match'), 
        movesMade = [], promotionPiece = "q", nextPlayer = 'white', status, connection = false, chatMessages = [];
        
        userData.player_color == "observer" ? $('.playerInput').hide() : $('#flipButton').hide();
        $('#whiteName').html(`${userData.white_name}`);
        $('#blackName').html(`${userData.black_name}`);
        $(document).ready(()=>{ $('#promotions').change(function(){ promotionPiece = $("input[name='promotion']:checked").val(); }); });
        $(document).ready(()=>{ $('#flip').click(function(){ board.setOrientation(ChessUtils.ORIENTATION.flip) }); });
        $(window).keydown((event)=>{ if (event.which === 13 && document.activeElement === document.getElementById('inputMessage')) { sendMessage(); }; });

        socket.on('connect', (data)=>{
            socket.emit('join', userData);
            connection = true;
        });

        socket.on('disconnect', (data)=>{
            console.log("Disconnected from server");
            connection = false;
            board.enableUserInput(false);
            resetConnections();
        });

        socket.on('reconnect', ()=>{
            connection = true;
            board.enableUserInput();
        });

        socket.on('messages', (data)=>{
            console.log(data);
        });

        socket.on('alert', (data)=>{
            alert(data);
        });

        socket.on('status', (data)=>{
            setStatus(data);
        });

        socket.on('moves', (data)=>{
            console.log(`${movesMade.length < data.length - 1 ? "moves" : "move"} received`);
            displayMove(data);
        });

        socket.on('chat', (data)=>{
            console.log(`${chatMessages.length < data.length - 1 ? "messages" : "message"} received`);
            displayChat(data);
        });

        resetConnections = ()=>{
            $('#whiteStatus').html(`disconnected`);
            $('#blackStatus').html(`disconnected`);
            $('#noObservers').show();
            $('#observers').empty();
        };

        resetGame = ()=>{
            board.setPosition(ChessUtils.FEN.startId);
            userData.player_color == "black" ? board.setOrientation(ChessUtils.ORIENTATION.black) : board.setOrientation(ChessUtils.ORIENTATION.white);
            chess.reset();
            board.enableUserInput(false);
            updateGameInfo('Next move is white.');
        };

        updateGameInfo = (status)=>{
          $('#status').html(status);
          $('#pgn').html(chess.pgn());
        };

        setStatus = (res)=>{
            resetConnections();
            for (let user of res) { 
                if (user.color == "white") { $('#whiteStatus').html(`connected`); }
                else if (user.color == "black") { $('#blackStatus').html(`connected`); }
                else { 
                    $('#noObservers').hide();
                    $('#observers').append(`${user.name}<br/>`); 
                };
            };
            if (!res.some(e => e.id == userData.player_id)) {
                console.log("fail");
                socket.close();
                socket.open();
            };
        }

        pieceMove = (move)=>{
            let chessMove = chess.move({
              from: move.from,
              to: move.to,
              promotion: promotionPiece
            });
            nextPlayer = 'white';
            if (chess.turn() === 'b') { nextPlayer = 'black'; };
            if (chessMove !== null) {
                movesMade.push(chessMove);
                if (chess.in_checkmate()) { status = 'CHECKMATE! Player ' + nextPlayer + ' lost.'; } 
                else if (chess.in_draw() || chess.in_threefold_repetition() || chess.in_stalemate()) { status = 'DRAW!'; } 
                else {
                    status = 'Next move is ' + nextPlayer + '.';
                    if (chess.in_check()) { status = 'CHECK! ' + status; };
                };
                let moveData = {
                    player_id: userData.player_id,
                    match_id: userData.match_id,
                    player_color: userData.player_color,
                    from: move.from,
                    to: move.to,
                    promotion: promotionPiece,
                    fen: chess.fen(),
                };
                board.enableUserInput(false);
                console.log("move sent");
                socket.emit('moveMade', moveData);
                updateGameInfo(status); 
            };
            return chess.fen();
        };

        pieceSelected = (notationSquare)=>{
            let i, movesNotation, movesPosition = [];
            movesNotation = chess.moves({square: notationSquare, verbose: true});
            for (i = 0; i < movesNotation.length; i++) { movesPosition.push(ChessUtils.convertNotationSquareToIndex(movesNotation[i].to)); };
            return movesPosition;
        };

        displayMove = (res)=>{
            console.log(`moves recorded: ${movesMade.length}`);
            console.log(`total moves: ${res.length}`);
            if (movesMade.length < res.length) {
                console.log("displaying new moves");
                let n = res.length - movesMade.length;
                for (i = n-1; 0 <= i; i--) {
                    let chessMove = chess.move({
                      from: res[i].from,
                      to: res[i].to,
                      promotion: res[i].promotion
                    });
                    movesMade.push(chessMove);
                    board.setPosition(res[i].fen);
                    nextPlayer = 'white';
                    if (chess.turn() === 'b') { nextPlayer = 'black'; };
                    if (chess.in_checkmate()) { status = 'CHECKMATE! Player ' + nextPlayer + ' lost.'; } 
                    else if (chess.in_draw() || chess.in_threefold_repetition() || chess.in_stalemate() ) { status = 'DRAW!'; }
                    else {
                        status = 'Next move is ' + nextPlayer + '.';
                        if (chess.in_check()) { status = 'CHECK! ' + status; };
                    }
                    updateGameInfo(status); 
                }
            }
            if (userData.player_color != "observer" && 
                userData.player_color == nextPlayer && 
                !chess.in_checkmate() &&
                !chess.in_draw() &&
                !chess.in_threefold_repetition() &&
                !chess.in_stalemate()) { board.enableUserInput(); }
        };

        sendMessage = () => {
            let message = $('#inputMessage').val();
            if (message && connection) {
                $('#inputMessage').val('')
                let chatData = {
                    text: message,
                    fen: chess.fen(),
                }
                console.log("message sent");
                socket.emit('chat', chatData);
            };
        };

        displayChat = (res)=>{
            console.log(`messages recorded: ${chatMessages.length}`);
            console.log(`total messages: ${res.length}`);
            if (chatMessages.length < res.length) {
                console.log("displaying new messages");
                let n = res.length - chatMessages.length;
                for (i = n-1; 0 <= i; i--) {
                    chatMessages.push(res)
                    let localTime = new Date(res[i].createdAt).toLocaleDateString(undefined, {
                        day:'numeric',
                        month: 'numeric',
                        year: '2-digit',
                        minute: 'numeric',
                        hour: 'numeric'
                    });
                    $('#chatDiv').append(`
                        <div id="messageID${chatMessages.length}" class=${res[i].player_id == userData.white_id ? "whiteMessage" : "blackMessage"}>
                            [${localTime}] <b>${res[i].player_id == userData.white_id ? userData.white_name : userData.black_name}</b>: ${res[i].player_message}
                        </div>
                    `);
                    document.getElementById("chatBox").scrollTop = document.getElementById("chatBox").scrollHeight;
                }
            }
        }

        let chess = new Chess(),
        board = new Chessboard('myBoard', {
            position: ChessUtils.FEN.startId,
            eventHandlers: {
                onPieceSelected: pieceSelected,
                onMove: pieceMove
            }
        });

        resetGame();

    </script>
</main>