<main>
    <p>Your color: {{player}}</p>
    <div id="myBoard" style="width: 100%; max-width: calc(100vh - 250px)"></div>
    <br/>
    <label>Status:</label>
    <div id="status"></div><br/>
    <label>Select a piece for pawn promotions (you may change this at any time):</label>
    <div id="promotions">
        <input type="radio" id="queen" name="promotion" value="q" checked="default">
        <label for="queen">Queen</label>
        <input type="radio" id="rook" name="promotion" value="r">
        <label for="rook">Rook</label>
        <input type="radio" id="knight" name="promotion" value="n">
        <label for="knight">Knight</label>
        <input type="radio" id="bishop" name="promotion" value="b">
        <label for="bishop">Bishop</label>
    </div><br/>
    <label>PGN:</label>
    <div id="pgn"></div>
    <script type="text/javascript">

        let decodedJson = decodeURIComponent("{{{encodedJson}}}"), userData = JSON.parse(decodedJson), movesMade = [], promotionPiece = "q";
        userData.upToDate = false;

        var chess = new Chess();

        var board = new Chessboard('myBoard', {
          position: ChessUtils.FEN.startId,
          eventHandlers: {
            onPieceSelected: pieceSelected,
            onMove: pieceMove
          }
        });

        $(document).ready(function(){
            $('#promotions').change(function(){
                promotionPiece = $("input[name='promotion']:checked").val();
            });
        });

        resetGame();

        function resetGame() {
          board.setPosition(ChessUtils.FEN.startId);
          userData.player_color == "white" ? board.setOrientation(ChessUtils.ORIENTATION.white) : board.setOrientation(ChessUtils.ORIENTATION.black);
          chess.reset();

          updateGameInfo('Next player is white.');
        }

        function updateGameInfo(status) {
          $('#status').html(status);
          $('#pgn').html(chess.pgn());
        }

        function pieceMove(move) {

          var nextPlayer,
            status,
            chessMove = chess.move({
              from: move.from,
              to: move.to,
              promotion: promotionPiece
            });


          nextPlayer = 'white';
          if (chess.turn() === 'b') {
            nextPlayer = 'black';
          }

          if (chessMove !== null) {
            movesMade.push(chessMove);
            if (chess.in_checkmate() === true) {
              status = 'CHECKMATE! Player ' + nextPlayer + ' lost.';
            } else if (chess.in_draw() === true) {
              status = 'DRAW!';
            } else {
              status = 'Next player is ' + nextPlayer + '.';

              if (chess.in_check() === true) {
                status = 'CHECK! ' + status;        
              }
            }

            let moveData = {
                player_id: userData.player_id,
                match_id: userData.match_id,
                player_color: userData.player_color,
                from: move.from,
                to: move.to,
                promotion: promotionPiece,
                fen: chess.fen(),
            };

            console.log("sending move");
            board.enableUserInput(false);
            $.post("/getmove", moveData, (res)=>{ 
                if (res == "retry") { getMovesFromServer(moveData); }
                else {
                    console.log(res);
                    opponentMove(res);
                };
            });

            updateGameInfo(status); 

          }

          return chess.fen();
        }

        function pieceSelected(notationSquare) {
          var i,
            movesNotation,
            movesPosition = [];

          movesNotation = chess.moves({square: notationSquare, verbose: true});
          for (i = 0; i < movesNotation.length; i++) {
            movesPosition.push(ChessUtils.convertNotationSquareToIndex(movesNotation[i].to));
          }
          return movesPosition;
        }

        opponentMove = (res)=>{
            console.log(movesMade.length < res.length);
            console.log(movesMade.length);
            console.log(res.length);
            if (movesMade.length < res.length) {
                console.log("moving");
                let n = res.length - movesMade.length;
                for (i = n; 0 < i; i--) {
                    let chessMove = chess.move({
                      from: res[i-1].from,
                      to: res[i-1].to,
                      promotion: res[i-1].promotion
                    });
                    movesMade.push(chessMove);
                    board.setPosition(res[i-1].fen);
                    console.log(chess.pgn());
                    nextPlayer = 'white';
                    let status;
                    if (chess.turn() === 'b') {
                        nextPlayer = 'black';
                    }

                    if (chess.in_checkmate() === true) {
                        status = 'CHECKMATE! Player ' + nextPlayer + ' lost.';
                    } else if (chess.in_draw() === true) {
                      status = 'DRAW!';
                    } else {
                      status = 'Next player is ' + nextPlayer + '.';

                    if (chess.in_check() === true) {
                        status = 'CHECK! ' + status;        
                    }

                    updateGameInfo(status); 

                    }
                }
                userData.upToDate = true;
                getMovesFromServer(userData);
            }
            else {
                board.enableUserInput();
            }
        };

        getMovesFromServer = (playerData)=>{
            board.enableUserInput(false);
            console.log("asking for move");
            $.post("/getmove", playerData, (res)=>{ 
                if (res == "retry") { getMovesFromServer(playerData); }
                else {
                    console.log(res);
                    opponentMove(res);
                };
            });
        };

        getMovesFromServer(userData);

        /*let decodedJson = decodeURIComponent("{{{encodedJson}}}"), userData = JSON.parse(decodedJson);
        userData.upToDate = false;
        //console.log(userData);
        let board = null, game = new Chess(), $status = $('#status'), $pgn = $('#pgn'), movesMade = [], promotionPiece = "q";

        onDragStart = (source, piece, position, orientation)=>{
          // do not pick up pieces if the game is over
            if (game.game_over()) return false;
          // do not pick up opponent's pieces
            if ((game.turn() === 'w' && userData.player_color == "black") ||
                (game.turn() === 'b' && userData.player_color == "white")) {
                return false;
            };
          // only pick up pieces for the side to move
            if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                return false;
            };
        };

        onDrop = (source, target)=>{
          // see if the move is legal
            let move = game.move({
                from: source,
                to: target,
                promotion: promotionPiece
            });
          // illegal move
            if (move === null) return 'snapback';
            updateStatus(move.san, true);
        };

        // update the board position after the piece snap
        // for castling, en passant, pawn promotion
        onSnapEnd = ()=>{ board.position(game.fen()); };

        updateStatus = (move, didPlayerMove)=>{
            if (move) movesMade.push(move);
            let status = '', moveColor = 'White'
            if (game.turn() === 'b') { moveColor = 'Black'; };
          // checkmate?
            if (game.in_checkmate()) { status = 'Game over, ' + moveColor + ' is in checkmate.'; }
          // draw?
            else if (game.in_draw()) { status = 'Game over, drawn position'; }
          // game still on
            else {
                status = moveColor + ' to move'
            // check?
                if (game.in_check()) { status += ', ' + moveColor + ' is in check'; };
            };
            $status.html(status);
            $pgn.html(game.pgn());
            let moveData = {
                player_id: userData.player_id,
                match_id: userData.match_id,
                player_color: userData.player_color,
                game_move: move
            };
            console.log(moveData);
            if ((game.turn() === 'w' && userData.player_color == "black" && didPlayerMove) ||
                (game.turn() === 'b' && userData.player_color == "white" && didPlayerMove)) {
                    console.log("sending move");
                    $.post("/getmove", moveData, (res)=>{ 
                        if (res == "retry") { getMovesFromServer(moveData); }
                        else {
                            console.log(res);
                            opponentMove(res);
                        };
                    });
            };
        };

        opponentMove = (res)=>{
            console.log(movesMade.length < res.length);
            console.log(movesMade.length);
            console.log(res.length);
            if (movesMade.length < res.length) {
                console.log("moving");
                let n = res.length - movesMade.length;
                for (i = n; 0 < i; i--) {
                    console.log(res[i-1].move);
                    game.move(res[i-1].move);
                    board.position(game.fen());
                    updateStatus(res[i-1].move, false);
                }
                userData.upToDate = true;
                getMovesFromServer(userData);
            }
        }

        let config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd
        };
        board = Chessboard('myBoard', config);
        if (userData.player_color == "black") board.orientation('black');

        $(document).ready(function(){
            $('#promotions').change(function(){
                promotionPiece = $("input[name='promotion']:checked").val();
            });
        });

        getMovesFromServer = (playerData)=>{
            console.log("asking for move");
            $.post("/getmove", playerData, (res)=>{ 
                if (res == "retry") { getMovesFromServer(playerData); }
                else {
                    console.log(res);
                    opponentMove(res);
                };
            });
        };

        getMovesFromServer(userData);
        updateStatus();*/

    </script>
</main>