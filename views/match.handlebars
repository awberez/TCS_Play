<main>
    <div class="container-fluid">
        <div class="row">
            <div class="col-12">
                <br/>
                <a href="https://thechessschool.net/home"><span id="logoBox"></span></a>
            </div>
            <hr/>
            <div class="col-12 text-center">
                <h1 id="headerText"></h1>
            </div>
        </div>
        <div class="row justify-content-center">
            <div class="col-6">
                <div class="infoBox">
                    <div class="outlineBar text-center">
                        <div id="status"></div>
                    </div>
                    <div class="row">
                        <div class="col-5">
                            <div id="connections">
                                <br/>
                                <div style="font-weight: bold">Observers:</div>
                                <div id="noObservers" style="font-style: italic">none</div>
                                <div id="observers" class="text-display"></div>
                            </div>
                            <br/>
                        </div>
                        <div class="col-7">
                            <div class="pgnDiv">
                                <br/>
                                <label style="font-weight: bold">PGN:</label>
                                <div id="pgn" class="textDisplay"></div>
                            </div>
                        </div>
                    </div>
                    <div class="chatDiv col-12">
                        <div id="chatBox">
                            <div id="chatDiv"></div>
                        </div>
                        <div id="chatTypeBox" class="playerInput justify-content-center">
                            <input id="inputMessage" placeholder="Type here..."/><button id="send" onClick=sendMessage()>Send</button>
                        </div>
                    </div>
                    <div class="outlineBar text-center bottom">
                        <div id="promotionsChoice" class="playerInput">
                            <label style="font-weight: bold">Pawn promotions:</label>
                            <select id="promotions">
                                <option value="q">Queen</option>
                                <option value="r">Rook</option>
                                <option value="n">Knight</option>
                                <option value="b">Bishop</option>
                            </select>  
                        </div>     
                    </div>
                </div>
            </div>
            <div class="col-6 text-center">
                <div class="infoBox chessBox">
                    <div id="topName" class="nameBox"></div>
                    <div id="myBoard"></div>
                    <div id="bottomName" class="nameBox"></div>
                    <div class="playerInput resignBtn">
                        <button id="resign" type="button">Resign</button>
                    </div>
                    <div id="flipButton">
                        <button id="flip" type="button">Flip Board</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script type="text/javascript">
        let decodedJson = decodeURIComponent("{{{encodedJson}}}"), userData = JSON.parse(decodedJson), socket = io('/match'), 
        movesMade = [], promotionPiece = "q", nextPlayer = 'white', status, resignation = false, gameEnd = false, chatMessages = [], topPlayer = "black",
        whiteName = `<div id="whiteName"><span class="whiteArrow">&rarr;</span> <span class="chessPiece white"></span> ${userData.white_name} <span id="whiteStatus" style="font-style: italic">(offline)</span> <span class="whiteArrow">&larr;</span></div>`,
        blackName = `<div id="blackName"><span class="blackArrow">&rarr;</span> <span class="chessPiece black"></span> ${userData.black_name} <span id="blackStatus" style="font-style: italic">(offline)</span> <span class="blackArrow">&larr;</span></div>`;
        userData.logo ? $('#logoBox').append(`<img src=${userData.logo}></img>`) : $("#logoBox").append(`<img src=/images/tcs-logo.png></img>`);
        userData.header ? $('#headerText').html(`${userData.header}`) : $('#headerText').html(`The Chess School`);
        userData.player_color == "observer" ? $('.playerInput').hide() : $('#flipButton').hide();
        if (userData.player_color == "black") {
            $('#topName').html(whiteName);
            $('#bottomName').html(blackName);
        } 
        else {
            $('#topName').html(blackName);
            $('#bottomName').html(whiteName);
        };   
        $(".whiteArrow").hide();
        $(".blackArrow").hide();
        $(document).ready(()=>{ $('#promotions').change(()=>{ promotionPiece = $("#promotions").val(); }); });
        $(document).ready(()=>{ $('#flip').click(flipBoard) });
        $(document).ready(()=>{ $('#resign').click(()=>{ resignGame(); }); });
        $(window).keydown((event)=>{ if (event.which === 13 && document.activeElement === document.getElementById('inputMessage')) { sendMessage(); }; });

        socket.on('connect', (data)=>{
            socket.emit('join', userData);
        });

        socket.on('disconnect', (data)=>{
            console.log("Disconnected from server");
            board.enableUserInput(false);
            $("#resign").attr("disabled", true); 
            $("#send").attr("disabled", true); 
            resetConnections();
        });

        socket.on('reconnect', ()=>{ 
            $("#resign").attr("disabled", false); 
            $("#send").attr("disabled", false); 
        });

        socket.on('messages', (data)=>{
            console.log(data);
        });

        socket.on('alert', (data)=>{
            alert(data);
        });

        socket.on('status', (data)=>{
            setConStatus(data);
        });

        socket.on('moves', (data)=>{
            console.log(`${movesMade.length < data.length - 1 ? "moves" : "move"} received`);
            displayMove(data);
        });

        socket.on('chat', (data)=>{
            console.log(`${chatMessages.length < data.length - 1 ? "messages" : "message"} received`);
            displayChat(data);
        });

        resetConnections = ()=>{
            $('#whiteStatus').html(`(offline)`);
            $('#blackStatus').html(`(offline)`);
            $('#noObservers').show();
            $('#observers').empty();
        };

        setConStatus = (res)=>{
            resetConnections();
            let coaches = [], observers = [];
            for (let user of res) {
                if (user.color == "white") { $('#whiteStatus').empty(); } else 
                if (user.color == "black") { $('#blackStatus').empty(); } else 
                if (user.is_coach) { coaches.push(user) }
                else { observers.push(user); };
            };
            if (coaches.length !== 0) {
                $('#noObservers').hide();
                coaches.sort((a, b) => (a.name > b.name) ? 1 : -1);
                for (coach of coaches) {  $('#observers').append(`${coach.name}&#9734;<br/>`); }
            }
            if (observers.length !== 0) {
                $('#noObservers').hide();
                observers.sort((a, b) => (a.name > b.name) ? 1 : -1);
                for (observer of observers) {  $('#observers').append(`${observer.name}<br/>`); }
            }
            if (!res.some(e => e.id == userData.player_id)) {
                console.log("fail");
                socket.close();
                socket.open();
            };
        };

        resetGame = ()=>{
            board.setPosition(ChessUtils.FEN.startId);
            userData.player_color == "black" ? board.setOrientation(ChessUtils.ORIENTATION.black) : board.setOrientation(ChessUtils.ORIENTATION.white);
            chess.reset();
            board.enableUserInput(false);
            status = 'White to move.';
            updateGameInfo();
        };

        updateGameInfo = ()=>{
            $('#status').html(status);
            $('#pgn').html(chess.pgn());
            document.getElementById("pgn").scrollTop = document.getElementById("pgn").scrollHeight;
            $(".whiteArrow").hide();
            $(".blackArrow").hide();
            if (!gameEnd) {
                nextPlayer == 'White' ? $(".whiteArrow").show() : $(".blackArrow").show();
            }
        };

        flipBoard = ()=>{
            board.setOrientation(ChessUtils.ORIENTATION.flip);
            topPlayer = (topPlayer == "white") ? "black" : "white";
            $('#topName').html(topPlayer == "white" ? whiteName : blackName);
            $('#bottomName').html(topPlayer == "white" ? blackName : whiteName);
        };

        changeGameStatus = ()=>{
            nextPlayer = 'White';
            if (chess.turn() === 'b') { nextPlayer = 'Black'; };
            if (chess.in_checkmate()) { gameEnd = (nextPlayer == 'White') ? "black" : "white", status = `CHECKMATE! ${nextPlayer == 'White' ? "Black" : "White"} wins!`; } else 
            if (chess.in_draw() || chess.in_threefold_repetition() || chess.in_stalemate()) { gameEnd = "draw", status = 'DRAW!'; } 
            else {
                status = `${nextPlayer} to move.`;
                if (chess.in_check()) { status = `CHECK! ${status}`; };
            };
            updateGameInfo(); 
        };

        pieceMove = (move)=>{
            let chessMove = chess.move({
              from: move.from,
              to: move.to,
              promotion: promotionPiece
            });
            if (chessMove !== null) {
                movesMade.push(chessMove);
                changeGameStatus();
                let moveData = {
                    from: move.from,
                    to: move.to,
                    promotion: promotionPiece,
                    fen: chess.fen(),
                    game_end: gameEnd,
                    move_id: movesMade.length
                };
                board.enableUserInput(false);
                console.log("move sent");
                if (socket.connected) { socket.emit('moveMade', moveData); }
                else { socket.on('reconnect', ()=>{ socket.emit('moveMade', moveData); }) };
            };
            return chess.fen();
        };

        pieceSelected = (notationSquare)=>{
            let i, movesNotation, movesPosition = [];
            movesNotation = chess.moves({square: notationSquare, verbose: true});
            for (i = 0; i < movesNotation.length; i++) { movesPosition.push(ChessUtils.convertNotationSquareToIndex(movesNotation[i].to)); };
            return movesPosition;
        };

        displayMove = (res)=>{
            console.log(`moves recorded: ${movesMade.length}`);
            console.log(`total moves: ${res.length}`);
            if (movesMade.length < res.length) {
                console.log("displaying new moves");
                let n = res.length - movesMade.length;
                for (i = n-1; 0 <= i; i--) {
                    if (!res[i].resign_id) {
                        let chessMove = chess.move({
                          from: res[i].from,
                          to: res[i].to,
                          promotion: res[i].promotion
                        });
                        movesMade.push(chessMove);
                        board.setPosition(res[i].fen);
                        changeGameStatus();
                    }
                    else {
                        resignation = true;
                        $("#resign").attr("disabled", true);
                        status = `RESIGNATION! ${res[i].resign_id == userData.white_id ? "White" : "Black"} has resigned!`;
                        updateGameInfo();
                    };
                };
            };
            if (userData.player_color != "observer" && 
                userData.player_color == nextPlayer.toLowerCase() && 
                !chess.in_checkmate() &&
                !chess.in_draw() &&
                !chess.in_threefold_repetition() &&
                !chess.in_stalemate() &&
                !resignation) { board.enableUserInput(); }
            else { board.enableUserInput(false); };
        };

        sendMessage = () => {
            let message = $('#inputMessage').val();
            if (message && socket.connected) {
                $('#inputMessage').val('')
                let chatData = {
                    text: message,
                    fen: chess.fen(),
                }
                console.log("message sent");
                socket.emit('chat', chatData);
            };
        };

        displayChat = (res)=>{
            console.log(`messages recorded: ${chatMessages.length}`);
            console.log(`total messages: ${res.length}`);
            if (chatMessages.length < res.length) {
                console.log("displaying new messages");
                let n = res.length - chatMessages.length;
                for (i = n-1; 0 <= i; i--) {
                    chatMessages.push(res)
                    let localTime = new Date(res[i].createdAt).toLocaleDateString(undefined, {
                        day:'numeric',
                        month: 'numeric',
                        year: '2-digit',
                        minute: 'numeric',
                        hour: 'numeric'
                    });
                    $('#chatDiv').append(`
                        <div id="messageID${chatMessages.length}" class=${res[i].player_id == userData.white_id ? "whiteMessage" : "blackMessage"}>
                            [<span class="timeDisplay">${localTime}</span>] ${res[i].player_id == userData.white_id ? `<span class="chessPiece white"></span>` : `<span class="chessPiece black"></span>`} ${res[i].player_message}
                        </div>
                    `);
                    document.getElementById("chatBox").scrollTop = document.getElementById("chatBox").scrollHeight;
                };
            };
        };

        resignGame = ()=>{
            let resign = confirm("Are you sure you want to resign?");
            if (resign && !resignation) {
                gameEnd = (userData.player_color == "white") ? "black" : "white";
                let resignData = {
                    fen: chess.fen(),
                    game_end: gameEnd,
                    resign: true,
                    move_id: movesMade.length
                };
                console.log("resignation sent");
                if (socket.connected) { socket.emit('moveMade', resignData); }
                else { socket.on('reconnect', ()=>{ socket.emit('moveMade', resignData); }) };
            }
        };

        let chess = new Chess(),
        board = new Chessboard('myBoard', {
            position: ChessUtils.FEN.startId,
            eventHandlers: {
                onPieceSelected: pieceSelected,
                onMove: pieceMove
            }
        });

        resetGame();

    </script>
</main>